git log    查看日志
git reflog 查看命令历史
git reset --hard commit_id 重置sha的id
git clone 克隆数据
Git的版本库里存了很多东西， 其中最重要的就是称为stage（或者叫index） 的暂存区， 还有Git为我们自动创建的第一个
分支master， 以及指向master的一个指针叫HEAD。
前面讲了我们把文件往Git版本库里添加的时候， 是分两步执行的：
第一步是用git add把文件添加进去， 实际上就是把文件修改添加到暂存区；
第二步是用git commit提交更改， 实际上就是把暂存区的所有内容提交到当前分支

你可以简单理解为， 需要提交的文件修改通通放到暂存区， 然后， 一次性提交暂存区的所有修改。
每次修改， 如果不用git add到暂存区， 那就不会加入到commit中。

用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage） ， 重新放回工作区：
场景1： 当你改乱了工作区某个文件的内容， 想直接丢弃工作区的修改时， 用命令git checkout -- file。
场景2： 当你不但改乱了工作区某个文件的内容， 还添加到了暂存区时， 想丢弃修改， 分两步， 第一步用命令git
reset HEAD <file>， 就回到了场景1， 第二步按场景1操作。
场景3： 已经提交了不合适的修改到版本库时， 想要撤销本次提交， 参考版本回退一节， 不过前提是没有推送到远程库
先手动删除文件， 然后使用git rm <file>和git add<file>效果是一样的。
ssh-keygen -t rsa -C "youremail@example.com"

git remote add origin git@github.com:everydatestudy/springbootstudy.git 这个是增加git的连接
git push -u origin master 把内容推送到服务器上面

在git bash中，运行下列命令： git config --global core.longpaths true
把本地库的内容推送到远程， 用git push命令， 实际上是把当前分支master推送到远程。

由于远程库是空的， 我们第一次推送master分支时， 加上了-u参数， Git不但会把本地的master分支内容推送的远程新
的master分支， 还会把本地的master分支和远程的master分支关联起来， 在以后的推送或者拉取时就可以简化命令。

首先， 我们创建dev分支， 然后切换到dev分支：
$ git checkout -b dev
Switched to a new branch 'dev'
git checkout命令加上-b参数表示创建并切换， 相当于以下两条命令：
$ git branch dev
$ git checkout dev
Switched to branch 'dev'
然后， 用git branch命令查看当前分支：
git merge命令用于合并指定分支到当前分支。 
查看分支： git branch
创建分支： git branch <name>
切换分支： git checkout <name>
创建+切换分支： git checkout -b <name>
合并某分支到当前分支： git merge <name>
删除分支： git branch -d <name>
冲突的解决
当Git无法自动合并分支时， 就必须首先解决冲突。 解决冲突后， 再提交， 合并完成。
解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容， 再提交。
用git log --graph命令可以看到分支合并图
git log --graph --pretty=oneline --abbrev-commit 查看日志
git stash 可以把当前工作现场“储藏”起来， 等以后恢复现场后继续工作：

再用git stash list查看， 就看不到任何stash内容了：
$ git stash list
你可以多次stash， 恢复的时候， 先用git stash list查看， 然后恢复指定的stash， 用命令
git stash apply stash@{0}
开发一个新feature， 最好新建一个分支；
如果要丢弃一个没有被合并过的分支， 可以通过git branch -D <name>强行删除

如果要推送其他分支， 比如dev， 就改成：
$ git push origin dev
git remote -v 远程详细的信息
现在， 你的小伙伴要在dev分支上开发， 就必须创建远程origin的dev分支到本地， 于是他用这个命令创建本地dev分支：
$ git checkout -b dev origin/dev
git pull也失败了， 原因是没有指定本地dev分支与远程origin/dev分支的链接， 根据提示， 设置dev和origin/dev的链接：
$ git branch --set-upstream-to=origin/dev dev
查看远程库信息， 使用git remote -v；

小结
查看远程库信息， 使用git remote -v；
本地新建的分支如果不推送到远程， 对其他人就是不可见的；
从本地推送分支， 使用git push origin branch-name， 如果推送失败， 先用git pull抓取远程的新提交；
在本地创建和远程分支对应的分支， 使用git checkout -b branch-name origin/branch-name， 本地和远程分支
的名称最好一致；
建立本地分支和远程分支的关联， 使用git branch --set-upstream branch-name origin/branch-name；
从远程抓取分支， 使用git pull， 如果有冲突， 要先处理冲突。
git rebase 重置的提交线
rebase操作可以把本地未push的分叉提交历史整理成直线；
rebase的目的是使得我们在查看历史提交的变化时更容易， 因为分叉的提交需要三方对比。

然后， 敲命令git tag <name>就可以打一个新标签：
git log --pretty=oneline --abbrev-commit 查看在线提交的
比方说要对add merge这次提交打标签， 它对应的commit id是f52c633， 敲入命令：
$ git tag v0.9 f52c633
注意， 标签不是按时间顺序列出， 而是按字母排序的。 可以用git show <tagname>查看标签信息：
diff --git a/readme.txt b/readme.txt

还可以创建带有说明的标签， 用-a指定标签名， -m指定说明文字：
$ git tag -a v0.1 -m "version 0.1 released" 1094adb

注意： 标签总是和某个commit挂钩。 如果这个commit既出现在master分支， 又出现在dev分支， 那么在这两个分支上都可以看到这个标签。

好在Git考虑到了大家的感受， 这个问题解决起来也很简单， 在Git工作区的根目录下创建一个特殊的.gitignore文件，
然后把要忽略的文件名填进去， Git就会自动忽略这些文件。
如果你确实想添加该文件， 可以用-f强制添加到Git：
$ git add -f App.class
或者你发现， 可能是.gitignore写得有问题， 需要找出来到底哪个规则写错了， 可以用git check-ignore命令检查：
$ git check-ignore -v App.class
.gitignore:3:*.class App.class

我们只需要敲一行命令， 告诉Git， 以后st就表示status：
$ git config --global alias.st status
${sys:user.home} 指的用户根目录 C盘 Users目录下用户目录下

获取用户HOME目录的占位符是“${sys:user.home}”，而不是之前的“${user.home}”